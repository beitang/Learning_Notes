# The Pragmatic Programmer

---

# Foreword
- They (authors) paid attention to what they were doing while they were doing it -- and then they tried to do it better.

---

# Preface
- Progamming is a craft.
- At its simplest, it comes down to getting a computer to do what you want it to do (or what your user wants it to do).
- As a programmer, you are part listener, part advisor, part interpreter, and part dictator.
- You try to capture elusive requirements and find a way of expressing them so that a mere machine can do them justice.
- You try to document your work so that others can understand it, and you try to engineer your work so that others can build on it.
- You try to do all this against the relentless ticking of the project clock.
- You work small miracles every day.
- It's a difficult job.
- There are no easy answers. There is no such thing as a best solution, be it a tool, a language, or an operating system. There can only be systems that are more appropriate in a prticular set of circumstances.
- This is where pragmatism comes in. You shouldn't be wedded to any particular technology, but have a broad enough background and experience base to allow you to choose good solutions in particular situations. Your background stems from an understanding of the basic principles of computer science, and your experience comes from a wide range of practical projects. Theory and practice combine to make you strong.
- You adjust your approach to suit the current circumstances and environment. You judge the relative importance of all the factors affecting a project and use your experience to produce appropriate solutions. And you do this continuously as the work progresses. Pragmatic Programmers get the job done, and do it well.

--- 

# Preface
## What Makes a Pragmatic Programmer?
- Early adopter fast adapter
- Inquisitive
- Critical thinker
- Realistic
- Jack of all trades
- Tip 1: Care About Your Craft
- Tip 2: Think! About Your Work
-- It's an ongoing critical appraisal of every decision you make, every day, and on every development.

---

# Preface
## It's a Continuous Process
- Kaizen is a Japanese term that captures the concept of continuously making many small improvements.
- Every day, work to refine the skills you have and to add new tools to your repertorie.

---

# Chapter 1. A Pragmatic Philosophy
- What distinguishes Pramatic Programmers? We feel it's an attitude, a style, a philosophy of approaching problems and their solutions.
- They think beyong the immediate problem, always trying to place it in its larger context, always trying to be aware of the bigger picture.
- Another key to their success is that they take responsibility for everything they do.
- Being responsible. Pragmatic Programmers won't sit idly by and watch their projects fall apart through neglect.
- Most people find change difficult to accept, sometimes for good reasons, sometimes because of plain old inertia. In Stone Soup and Boiled Frogs, we look at a strategy for instigating change and (in the interests of balance) present the cautionary tale of an amphibian that ignored the dangers of gradual change.
- You need to have a broad base of knowledge and experience to pull all of this off. Learning is a continuous and ongoing process.

---

# Chapter 1. A Pragmatic Philosophy
## The Cat Ate My Source Code
- "The greatest of all weaknesses is the fear of appearing weak."
- One of the cornerstones of the pragmatic philosophy is the idea of taking responsibility for yourself and your actions in terms of your career advancement, your project, and your day-to-day work.
- A Pragmatic Programmer takes charge of his or her own career, and isn't afraid to admit ignorance or error.
- We can be proud of our abilities, but we must be honest about our shortcomings -- our ignorance as well as our mistakes.
- Take Responsibility
- Responsibility is something you actively agree to. You make a commitment to ensure that something is done right, but you don't necessarily have direct control over every aspect of it. In addition to doing your own personal best, you must analyze the situation for risks that are beyong your control. You have the right not to take on a responsibility for an impossible situation, or one in which the risks are too great. You'll have to make the call based on your own ethics and judgment.
- When you do accept the responsibility for an outcome, you should expect to be held accountable for it. When you make a mistake or an error in judgment, admit it honestly and try to offer options.
- Don't blame someone or something else, or make up an excuse. Don't blame all the problems on a vendor, a programming language, management, or your coworkers. Any and all of these may play a role, but it is up to you to provide solutions, not excuses.
- Tip 3: Provide Options. Don't Make Lame Excuses.
- Before you approach anyone to tell them why something can't be done, is late, or is broken, stop and listen to yourself. Talk to the rubber duck on your monitor, or the cat. Does your excuse sound reasonable, or stupid? How's it going to sound to your boss?
- Run through the conversation in your mind. What is the other person likely to say? Will they ask, "Have you tried this ..." or "Didn't you consider that?" How will you respond? Before you go and tell them the bad news, is there anything else you can try? Sometimes, you just know what they are going to say, so save them the trouble.
- Instead of excuses, provide options. Don't say it can't be done; explain what can be done to salvage the situation.
- Try to flush out the lame excuses before vocing them alound. If you must, tell your cat first. After all, if little Tiddles is going to take the blame...

---

# Chapter 1. A Pragmatic Philosophy
## Softwre Entropy
- When disorder increases in software, programmers call it "software rot."
- There are many factors that can contribute to software rot. The most important one seems to be the psychology, or culture, at work on a project.
- One broken window, left unrepaired for any substaintial length of time, instills in the inhabitants of the building a sense of abandonment. So another window gets broken. People start littering. Graffiti appears. Serious structural damage begins. In a relatively short space of time, the building becomes damaged beyond the owner's desire to fix it, and the sense of abandonment becomes reality.
- Tip 4: Don't Live with Broken Windows
- Don't leave "broken windows" (bad designs, wroing decision, or poor code) unrepaired. Fix each one as soon as it is discovered. If there is insufficient time to fix it properly, then board it up. Perhaps you can comment out the offending code, or display a "Not Implemented" message, or substitue dummy adata instead. Take some action to prevent further damage and to show that you're on tope of the situation.
- Neglect accelerates the rot faster than any other factor.
- One broken window -- a badly designed piece of code, a poor management decision that the team must live for the duration of the project -- is all it takes to start the decline.

---

# Chapter 1. A Pragmatic Philosophy
## Stone Soup and Boiled Frogs
- The soldiers act as a catalyst.
- Work out what you can reasonably ask for. Develop it well. Once you've got it, show people, and let them marvel. Then say "of course, it would be better if we added ..." Pretend it's not important. Sit back and wait for them to start asking you to add the functionality you originally wanted.
- People find it easier to join and ongoing success. Show them a glimpse of the future and you'll get them to rally around.
- Tip 5: Be a Catalyst for Change
- Projects slowly and inexorably get totally out of hand. Most software disasters start out too small to notice, and most project overruns happen a day at a time. Systems drift from their specifications feature by feature, while patch after patch gets added to a piece of code until there's nothing of the original left. It's often the accumulation of small things that breaks morale and teams.
- Tip 6: Remember the Big Picture
- Don't be like the frog. Keep an eye on the big picture. Constantly review what's happening around you, not just what you personally are doing.

---

# Chapter 1. A Pragmatic Philosophy
## Good-Enough Software
- "Striving to better, oft we mar what's well."
- You can discipline yourself to write software that's good enough -- good enough for your users, for future maintainers, for your own peace of mind.
- We are simply advocating that users be given an opportunity to participate in the process of deciding when what you've produced is good enough.
- Involve Your Users in the Trade-Off
- The scope and quality of the system you produce should be specified as part of that system's requirements.
- Tip 7: Make Quality a Requirements Issue
- Great software today is often preferable to perfect software tomorrow.
- If you give your users something to play with early, their feedback will often lead you to a better eventual solution.
- Know When to Stop
- Don't spoil a perfectly good program by overembellishment and over-refinement. Move on, and let your code stand in its own right for a while. It may not be perfect. Don't worry: it could never be perfect.

---

# Chapter 1: A Pragmatic Philosophy
## Your Knowledge Portfolio
- "An investment in knowledge always pays the best interest."
- Your knowledge becomes out of date as new techniques, languages, and environments are developed. Changing market forces may render your experience obsolete or irrelevant.
- We like to think of all the facts programmers know about computing, the application domains they work in, and all their experience as their Knowledge Portfolios.
- 1. Serious investors invest regularly -- as a habit.
- 2. Diversification is the key to long-term success.
- 3. Smart investors balance their portfolios between conservative and high-risk, high-reward investments.
- 4. Investors try to buy low and sell high for maximum return.
- 5. Portfolios should be reviewed and rebalanced periodically.
- Building Your Portfolio
- 1. Invest regularly.
- 2. Diversify. The more different things you know, the more valuable you are. The more technologies you are comfortable with, the better you will be able to adjust to change.
- 3. Manage risk. It's not a good idea to invest all of your money in high-risk stocks that might collapse suddenly, nor should you invest all of it conservatively and miss out on possible opportunities.
- 4. Buy low, sell high. Learning an emerging techology before it becomes popular can be just as hard as finding an undervalued stock, but the payoff can be just as rewarding.
- 5. Review and rebalance.
- Tip 8: Invest Regularly in Your Knowledge Portfolio
- A few suggestions
- 1. Learn at least one new language every year. Different languages solve the same problems in different ways. By learning several different approaches, you can help broaden your thinking and avoid getting stuck in a rut.
- 2. Read a technical book each quarter. -- Where to find?
- 3. Take classes. -- How about coursa?
- 4. Participate in local user groups. Don't just go and listen, but actively participate. Isolation can be deadly to your career; find out what people are working on outside of your company. -- AnyCode, how to find about other company?
- 5. Experiment with different environments. Windows vs. Linux. Editor vs. IDE. -- Try Eclipse
- 6. Stay current. Subscribe to trade magazines and other journals. Choose some that cover technology different from that of your current project. -- How to find such? Ask AnyCode?
- 7. Get wired. Newsgroups are a great way to find out what experiences other people are having with it, the particular jargon they use, and so on. Surf the Web for papers, commercial sites, and any other sources of information you can find.
- It's important to continue investing. Once you feel comfortable with some new language or bit of technology, move on. Learn another one.
- It doesn't matter whether you ever use any of these technologies on a project, or even whether you put them on your resume. The process of learning will expand your thinking, opening you to new possibilities and new ways of doing things. The cross-pollination of ideas is important; try to apply the lessons you've learned to your current project. Even if your project doesn't use that technology, perhaps you can borrow some ideas. Get familiar with object orientation, for instance, and you'll write plain C programs differently.
- Opportunities for Learning
- Somebody asks you a question. You don't have the faintest idea what the answer is, and freely admit as much. Don't let it stop there. Take it as a personal challenge to find the answer. Ask a guru, search the Web, go to the library.
- If you can't find the answer yourself, find out who can. Don't let it rest. Talking to other people will help build your personal network, and you may surprise yourself by finding solutions to other, unrelated problems along the way. And that old portfolio just keeps getting bigger...
- All of this reading and researching takes time, and time is already in short supply. So you need to plan ahead. Always have something to read in an otherwise dead moment.
- Critical Thinking
- The last important point is to think critically about what you read and hear. You need to ensure that the knowledge in your portfolio is accurate and unswayed by either vendor or media hype. Beware of the zealots who insist that their dogma provides the only answer -- it may or may not be applicable to you and your project.
- Tip 9: Critically Analyze What You Read and Hear
- Start reading a new book. If you are doing very detailed implementation and coding, read a book on design and architecture. If you are doing high-level design, read a book on coding techniques.
- Care and Cultivation of Gurus: some simple tricks
-- Know exactly what you want to ask, and be as specific as you can be.
-- Frame your question carefully and politely.
-- Once you've framed your question, stop and look again for the answer. Pick out some keywords and search the web. Look for appropriate FAQs.
-- Decide if you want to ask publicly or privately.
-- Sit back and be patient. People are busy, and it may take days to get a specific answer.
-- Finally, please be sure to thank anyone who responds you. And if you see people asking questions you can answer, play your part and participate.

---

# Chapter 1: A Pragmatic Philosophy
## Communicate
- Having the best ideas, the finest code, or the most pragmatic thinking is ultimately sterile unless you can communicate with other people. A good idea is an orphan without effective communication.
- Know What You Want to Say
-- Plan what you want to say. Write an outline. Then ask youself, "Does this get across whatever I'm trying to say?" Refine it until it does.
-- This approach is not just applicable to writing documents. When you're faced with an important meeting or a phone call with a major client, jot down the ideas you want to communicate, and plan a couple of strategies for getting them across.
- Know Your Audience
-- You're communicating only if you're conveying information. To do that, you need to understand the needs, interests, and capabilities of your audience.
-- The wisdom acrostic -- understanding an audience: What do you want them to learn? What is their interest in what you've got to say? How sophisticated are they? How much detail do they want? Whom do you want to own the information? How can you motivate them to listen to you?
- Choose Your Moment
-- As part of understanding what your audience needs to hear, you need to work out what their priorities are.
- Choose a Style
-- Kind of feedback is a form of communication.
-- Long or short
- Make It Look Good
-- Too many developers concentrate solely on content when producing written document. We think this is a mistake.
-- There is no excuse today for producing poor-looking printed documents.
-- Check the spelling, first automatically and then by hand.
- Involve Your Audience
-- If possible, involve your readers with early drafts of your document. Get their feedback, and pick their brains. You'll build a good working relationship, and you'll probably produce a better document in the process.
- Be a Listener
-- There's one technique that you must use if you want people to listen to you: listen to them.
-- Encourage people to talk by asking questions, or have them summarize what you tell them. Turn the meeting into a dialog, and you'll make your point more effectively. Who knows, you might even learn something.
- Get Back to People
-- Always respond to e-mails and voice mails, even if the response is simply "I'll get back to you later."
-- Keeping people informed makes them far more forgiving of the occasional slip, and makes them feel that you haven't forgotten them.
- Tip 10: It's Both What You Say and the Why You Say it
- Unless you work in a vacuum, you need to be able to communicate. The more effective that communication, the more influential you become.
- E-Mail Communication
-- Proofread before you hit send
-- Check the spelling
-- Keep the format simple
-- Plain text is universal
-- Try to keep quoting to a minimum
-- If you're quoting other people's e-mail, be sure to attribute it, and quote it inline (rather than as an attachment)
-- Don't flame unless you want it to come back and haunt you later
-- Check your list of recipients before sending
-- Archive and organize your e-mail -- both the import stuff you receive and the mail you send

---

# Chapter 2: A Pragmatic Approach
- There are certain tips and tricks that apply at all levels of software development, ideas that are almost axiomatic, and processes that are virtualy universal. However, these approaches are rarely documented as such; you'll mostly find them written down as odd sentences in discussions of design, project management, or coding.
- The first two sections, The Evils of Duplication and Orthogonality, are closely related. The first warns you not to duplicate knowledge throughout your systems, the second not to split any one piece of knowledge across multiple system components.

---

# Chapter 2: A Pragmatic Approach
## The Evils of Duplication
- Programmers are constantly in maintenance mode. Our understanding changes day by day. New requirements arrive as we're designing or coding. Perhaps the environment changes. Whatever the reason, maintenance is not a discrete activity, but a routine part of the entire development process.
- The problem is that it's easy to duplicate knowledge in the specifications, processes, and programs that we develop, and when we do so, we invite a maintenance nightmare.
- We feel that the only way to develop software reliably, and to make our developments easier to understand and maintain, is to follow what we call the DRY principle:
- Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
- Tip 11: DRY -- Don't Repeat Yourself
- We feel that it is one of the most important tools in the Pragmatic Programmer's tool box.
- How Does Duplication Arise?
-- Imposed duplication. Developers feel they have no choice -- the environment seems to require duplication.
-- Inadvertent duplication. Developers don't realize that they are duplicating information.
-- Impatient duplication. Developers get lazy and duplicate because it seems easier.
-- Interdeveloper duplication. Multiple people on a team (or on different teams) duplicate a piece of information.
- Imposed Duplication
-- Multiple representation of information. At the coding level, we often need to have the same information represented in different forms. One answer is to write a simple filter or code generator. Structures in multiple languages can be built from a common metadata representation using a simple code generator each time the software is built. Class definitions can be generated automatically from the online database schema, or from the metadata used to build the schema in the first place.
- Documentation in code
-- Bad code requires lots of comments
-- The DRY principle tells us to keep the low-level knowledge in the code, where it belongs, and reserve the comments for other, high-level explanations.
- Documentation and code
-- Generate tests programmatically from the document itself
- Language issues
-- Use the header files to document interface issues, and the implementation files to document the nitty-gritty details that users of your code don't need to know.
- Inadvertent Duplication
-- Sometimes, duplication comes about as the result of mistakes in the design.
-- A  slightly less obvious kind of unnormalized data: The length is defined by the start and end points, change one of the points and the length changes.
-- Later on in the development process, you may choose to violate the DRY principle for performance reasons. Frequently this occurs when you need to cache data to avoid repeating expensive operations. The trick is to localize the impact. The violation is not exposed to the outside world: only the methods within the class have to worry about keeping things straight.
-- For OO languages, when possible, always use accessor functions to read and write the attributes of ojbects. It will make it easier to add functionality, such as caching, in the future.
- Impatient Duplication
-- If you feel this temptation (to copy), remember the hackneyed aphorism "shortcuts make for long delays". You may well save some seconds now, but at the potential loss of hours later.
-- Impatient duplication is an easy form to detect and handle, but it takes discipline and a willingness to spend time up front to save pain later.
- Interdeveloper Duplication
-- Perhaps the hardest type of duplication to detect and handle occurs between different developers on a project.
-- At a high level, deal with the problem by having a clear design, a strong technical project leader, and a well-understood division of responsibilities within the design.
-- However, at the module level, the problem is more insidious. Commonly needed functionality or data that doesn't fall into an obvious area of responsibility can get implemented many times over.
-- We feel that the best way to deal with this is to encourage active and frequent communication between developers. Set up forms to discuss common problems.
- Tip 12: Make It Easy to Reuse
-- What you're trying to do is foster an environment where it's easier to find and reuse existing stuff than to write it yourself.
-- If it isn't easy, people won't do it. And if you fail to reuse, you risk duplicating knowledge.

---

# Chapter 2: A Pragmatic Approach
## Orthogonality
- Orthogonality is a critical concept if you want to produce systems that are easy to design, build, test, and extend.
- What Is Orthogonality?
-- In computing, the term has come to signify a kind of independence or decoupling. Two or more things are orthogonal if changes in one do not affect any of the others. In a well-designed system, the database code will be orthogonal to the user interface: you can change the interface without affecting the database, and swap database without changing the interface.
- Benefits of Orthogonality
- Tip 13: Eliminate Effects Between Unrelated Things
- You want to design components that are self-contained: independent, and with a single, well-defined purpose. As long as you don't change that component's external interfaces, you can be comfortable that you won't cause problems that ripple through the entire system.
- You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.
- Gain Productivity
-- Changes are localized, so development time and testing time are reduced.
-- An orthogonal approach also promotes reuse.
-- There is a fairly subtle gain in productivity when you combine orthogonal components.
- Reduce Risk
-- Diseased sections of code are isolated.
-- The resulting system is less fragile.
-- An orghogonal system will probably be better tested, because it will be easier to design and run tests on its components.
-- You will not be as tightly tied to a particular vendor, product, or platform, because the interfaces to these third-party components will be isolated to smaller parts of the overall develpment.
- Let's look at some of the ways you can apply the principle of orthogonality to your work.
- Project Teams
-- When teams are organized with lots of overlap, members are confused about responsibilities. Every change needs a meeting of the entire team, because any one of them might be affected.
-- Our preference is to start by separating infrastructure from application. Each major infrastructure component (database, communications interface, middleware layer, and so on) gets its own subteam. Each obvious division of application functionality is similarly divided. Then we look at the people we have and adjust the groupings accordingly.
-- You can get an informal measure of the orghogonality of a project team's structure. Simply see how many people need to be involved in discussing each change that is requested. The larger the number, the less orthogonal the group. Clearly, and orthogonal team is more efficient. (Having said this, we also encourage subteams to communicate constantly with each other.)
- Design
-- There is an easy test for orthogonal design. Once you have your components mapped out, ask yourself: If I dramatically change the requirements behind a particular function, how many modules are affected? In an orthogoanl system, the answer should be "one".
-- Also ask yourself how decoupled your desing is from changes in the real world. Are you using a telephone number as a customer identifier? What happens when the phone company reassigns area codes? Don't rely on the properties of things you can't control.
- Toolkits and Libraries
-- Be careful to preserve the orthogonality of your system as you introduce third-party toolkits and libraries. Choose your technologies wisely.
-- When you bring in a toolkit (or even a library from other members of your team), ask yourself whether it imposes changes on your code that shouldn't be there. If an object persistence scheme is transparent, then it's orthogonal. If it requires you to create or access objects in a special way, then it's not. Keeping such details isolated from your code has the added benefit of making it easier to change venders in the future.
-- The Enterprise Java Beans (EJB) system is an interesting example of orthogonality.
-- Another interesting twist on orthogonality is Aspect-Oriented Programming (AOP), a research project at Xerox parc.
- Coding
-- Keep your code decoupled. Write shy code -- modules that don't reveal anything unnecessary to other modules and that don't rely on other modules' implementations.
-- Avoid global data. In object-oriented applications, context if often passed as parameters to objects' consctructors. In other code, you can create structures containing the context and pass around references to them.
-- The Singleton pattern in Design Patterns is a way of ensureing that there is only one instance of an object of a particular class. Many people use these singleton objects as a kind of global variable. Be caureful with singletons -- they can also lead to unnecessary linkage.
-- Avoid similar functions. Have a look at the Strategy pattern in Design Patterns for a better implementation.
-- Get into the habit of being constantly critical of your code. Look for any opportunities to reorganize it to improve its structure and orthogonality. This process is called refactoring.
- Testing
-- An orthogonally designed and implemented system is easier to test.
-- Building unit test is itself an interesting test of orthogonality.
-- Bug fixing is also a good time to assess the orthogonality of the system as a whole.
-- If you use a source code control system, tag bug fixes when you check the code back in after testing. You can then run montly reports analyzing trends in the number of source files affected by each bug fix.
- Documentation
-- The axes are content and presentation. With truly orthogonal documentation, you should be able to change the appearance dramatically without changing the content. Modern word processors provide style sheets and macros that help.
- Living with Orthogonality
-- If you're brought into a project where people are desperately struggling to make changes, and where every change seems to cause four other things to go wrong, remember the nightmare with the helicopter. The project probably is not orthogonally designed and coded. It's time to refactor.

---

# Chapter 2: A Pragmatic Approach
## Reversibility
- "Nothing is more dangerous than an idea of it's the only one you have."
- Nothing is forever - and if you rely heavily on some fact, you can almost guarantee that it will change.
- There is always more than one way to implement something, and there is usually more than one vendor available to provide a third-party product.
- The problem is that critical decisions aren't easily reversible. Once you decide to use this vendor's database, or that architectural pattern, or a certain deployment model, you are committed to a course of action that cannot be undone, except at great expense.
- Reversibility
-- Many of the topics in this book are geared to producing flexible, adaptable software. By sticking to their recommendations - especially the DRY principle, decoupling, and use of metadata - we don't have to make as many critical, irreversible decisions.
-- The mistake lies in assuming that any decision is cast in stone - and in not preparing for the contingencies that might arise. Instead of carving decisions in stone, think of them more as being written in the sand at the beach. A big wave can come along and wipe them out at any time.
- Tip 14: There Are No Final Decisions
- Flexible Architecture
-- While many people try to keep their code flexible, you also need to think about maintaining flexibility in the areas of architecture, deployment, and vendor integration.
-- Technologies such as CORBA can help insulate portions of a project from changes in development language or platform.
-- Not sure how marketing wants to deploy the system? Think about it up front and you can support a stand-alone, client-server, or n-tier model just by changing a configuration file.
-- Normally, you can simply hide a third-party product behind a well-defined, abstract interface.
-- What if you had to sprinkle certain statements liberally throughout the code? Put that requirement in metadata, and use some automatic mechanism, such as Aspects or Perl, to insert the necessary statements into the code itself.
-- Whatever mechanism you use, make it reversible. If something is added automatically, it can be taken out automatically as well.
- No wonder coding for the future is difficult.

---

# Chapter 2: A Pragmatic Approach
## Tracer Bullets
- Like the gunners, you're trying to hit a targit in the dark. Because your users have never seen a system like this before, their requirements may be vague. Because you may be using algorithms, techniques, languages, or libraries you aren't familiar with, you face a large number of unknowns. And because projects take tiime to complete, you can pretty much guarantee the environment you're working in will change before you're done.
- The classic response is to specify the system to death. Produce reams of paper itemizing every requirement, tying down every unknown, and constraining the environment. Fire the gun using dead reckoning. One big calculation up front, then shoot and hope.
- Pragmatic Programmers, however, tend to prefer using tracer bulltes.
- Code That Glows in the Dark
- Tracer bullets work because they operate in the same environment and under the same constraints as the real bullets. They get to the target fast, so the gunner gets immediate feedback. And from a practical standpoint they're a relatively cheap solution.
- To get the same effect in code, we're looking for something that gets us from a requirement to some aspect of the final system quickly, visibly, and repeatly.
- Tip 15: Use Tracer Bullets to Find the Target
- Tracer code is not disposable: you write it for keeps. It contains all the error checking, structuring, documentation, and self-checking that any piece of production code has. It simply is not fully functional. However, once you have achieved an end-to-end connection among the components of your system, you can check how close to the target you are, adjusting if necessary. Once you're on target, adding functionality is easy.
- Tracer development is consistent with the idea that a project is never finished: there will always be changes required and functions to add. It is an incremental approach.
- The tracer code approach has many advantages:
-- Users get to see something working early.
-- Developers build a structure to work in.
-- You have an integration platform.
-- You have something to demonstrate.
-- You have a better feel for progress.
- Tracer Bullets Don't Always Hit Their Target
-- Tracer bullets show what you're hitting. This may not always be the target. You then adjust your aim until they're on target. That's the point.
- Tracer Code versus Prototyping
-- With a prototype, you're aiming to explore specific aspects of the final system. With a true prototype, you will throw away whatever you lashed together when trying out the concept, and recode it properly using the lessons you've learned.
-- You need to know how the applications as a whole hangs together. You want to show your users how the interactions will work in practice, and you want to give your developers an architectural skeleton on which to hang code.
-- Prototyping generates disposable code. Tracer code is lean but complete, and forms part of the skeleton of the final system. Think of prototyping as the reconnaissance and intelligence gathering that takes place before a single tracer bullet is fired.

---

# Chapter 2: A Pragmatic Approach
## Prototypes and Post-it Notes
- We build software prototypes to analyze and expose risk, and to offer changes for correction at a greatly reduced cost.
- Post-it notes are great for prototyping dynamic things such as workflow and application logic. A user interface can be prototyped as a drawing on a whiteboard, as a nonfunctional mock-up drawn with a paint program, or with an interface builder.
- Prototypes are designed to answer just a few questions, so they are much cheaper and faster to develop than applications that go into production.
- Things to Prototype
- Anything that carries risk. Anything that hasn't been tried before, or that is absolutely critical to the final system. Anything unproven, experimental, or doubtful. Anything you aren't comfortable with.
-- Architecture
-- New functionality in an existing system
-- Structure or contents of external data
-- Third-party tools or components
-- Performance issues
-- User interface design
- Prototyping is a learning experience. Its value lies not in the code produced, but in the lessons learned. That's really the point of prototyping.
- Tip 16: Prototype to Learn
- How to User Prototypes
- What details can you ignore?
-- Correctness
-- Completeness
-- Robostness
-- Style
- Since a prototype should gloss over details, and focus in on specific aspects of the system being considered, you may want to implement prototypes using a very high-level language -- higher than the rest of the project. A high-level scripting language lets you defer many details and still produce a functional piece of code.
- Scripting languages work well as the "glue" to combine low-level pieces into new combinations.
- Prototyping Architecture
-- What you are looking for is how the system hangs together as a whole, again defering details.
- Here are some specific areas you may want to look for in the architectural prototype
-- Are the responsibilities of the major components well defined and appropritate?
-- Are the collaborations between major components well defined?
-- Is coupling minimized?
-- Can you identify potential sources of duplication?
-- Are interface definitions and constraints acceptable?
-- Does every module have an access path to the data it needs during execution? Does it have that access when it needs it?
- How Not to Use Prototypes
- Before you embark on any code-based prototyping, make sure that everyone understands that you are writing disposable code. Prototypes can be deceptively attractive to people who don't know that they are just prototypes. You must make it very clear that this code is disposable, incomplete, and unable to be completed.
- When used properly, a prototype can save you huge amounts of time, money, pain, and suffering by identifying and correcting potential problem spots early in the development cycle - the time when fixing mistakes is both cheap and easy.

---

# Chapter 2: A Pragmatic Approach
## Domain Languages -- Not understand quite a lot
- "The limits of language are the limites of one's world."
- Computer languages influence how you think about a problem, and how you think about communicating.
- The language of the problem domain may also suggest a programming solution.
- Tip 17: Program Close to the Problem Domain
- By coding at a higher level of abstraction, you are free to concentrate on solving domain problems, and can ignore petty implementation details.
- Remember that there are many users of an application. Each of these users has their own problem domain, and you can generate mini-environments and languages for all of them.
- Implementing a Mini-Language
- Data Languages and Imperative Languages
- Data languages produce some form of data structure used by an application. These languages are often used to represent configuration information.
- Stand-Alone and Embedded Languages
- We invent a common language to express the database schema, and then generated all the forms of it we needed -- SQL, C, Web pages, XML, and others.
- Easy Development or Easy Maintenance?
- The trade-off is extendibility and maintenance. While the code for parsing a 'real' language may be harder to write, it will be much easier for people to understand, and to extend in the future with new features and functionality.

---

# Chapter 2: A Pragmatic Approach
## Estimating
- By learning to estimate, and by developing this skill to the point where you have an intuitive feel for the magnitudes of things, you will be able to show an apparent magical ability to determine their feasibility.
- Tip 18: Estimate to Avoid Surprises
- How Accurate Is Accurate Enough?
-- To some extend, all answers are estimates. It's just that some are more accurate than others. So the first question you have to ask youself when someone asks you for an estimate is the context in which your answer will be taken. Do they need high accuracy, or are they looking for a ballpark figure?
-- One of the interesting things about estimating is that the units you use make a difference in the interpretation of the result.
-- The same concepts apply to estimates of any quantity: choose the units of your answer to reflect the accurary you intend to convey.
- Where Do Estimates Come From?
-- All estimates are based on models of the problem. But before we get too deeply into the techniques of building models, we have to mention a basic estimating trick that always gives good answers: ask someone who's already done it. Before you get too committed to model building, cast around for someone who's been in a similar situation in the past.
-- Understand What's Being Asked
-- The first part of any estimation exercise is building an understanding of what's being asked.
-- You need to make it a habit to think about the scope before starting to guess.
-- Building a Model of the System
-- From your understanding of the question being asked, build a rough and ready bare-bones mental model.
-- Model building can be both creative and useful in the long term. Often, the process of building the model leads to discoveries of the underlying patterns and processes that weren't apparent on the surface. You may even want to reexamine the original question.
-- Building the model introduces inaccuracies into the estimating process. This is inevitable, and also beneficial. You are trading off model simplicity for accurary. Doubling the effor t on the model may give you only a slight increase in accuracy. Your experience will tell you when to stop refining.
-- Break the Model into Components
-- You'll find that each component will typically have parameters that affect how it contributes to the overall model. At this stage, simply identify each parameter.
-- Give Each Parameter a Value
-- Calculate the Ansers
-- Run multiple calculations, varying the values of the critical parameters, until you work out which ones really drive the model. A spreadsheet can be a big help.
-- Keep Track of Your Estimating Prowess
-- We think it's a great idea to record your estimates so you can see how close you were.
-- When an estimate turns out wrong, don't just shrug and walk away. Find out why it differed from your guess. Maybe you chose some parameters that didn't match the reality of the problem. Maybe your model was wrong. Whatever the reason, take some time to uncover what happened. If you do, your next estimate will be better.
- Estimating Project Schedules
-- We find that often the only way to determine the timetable for a project is by gaining experience on that same project.
-- This needn't be a paradox if you practice incremental development, repeating the following steps.
-- Check requirements
-- Analyze risk
-- Design, implement, integrate
-- Validata with the users
- Tip 19: Iterate the Schedule with the Code
- What to Say When Asked for an Estimate
-- You say "I'll get back to you." You almost always get better results if you slow the process down and spend some time going through the steps we describe in this section. Estimates given at the coffee machine will come back to haunt you.

---

# Chapter 3: The Basic Tools
- Then begins a process of learning and adaptation. Each tool will have its own personality and quirks, and will need its own special handling. Each must be sharpened in a unique way, or held just so.
- Tools amplify your talent. The better your tools, and the better you know how to use them, the more productive you can be.
- Start with a basic set of generally applicable tools. As you gain experience, and as you come across special requirements, you'll add to this basic set.
- Always be on the lookout for better ways of doing things.
- Many new programmers make the mistake of adopting a single power tool, such as a particular integrated development environment, and never leave its cozy interface. This really is a mistake. We need to be comfortable beyond the limits imposed by an IDE. The only way to do this is to keep the basic tool set sharp and ready to use.

---

# Chapter 3: The Basic Tools
## The Power of Plain Text
- As Pragmatic Programmers, our base material isn't wood or iron, it's knowledge. We gather requirements as konwledge, and then express that knowledge in our designs, implementations, tests, and documents.
- And we believe that the best format for storing knowledge persistently is plain text.
- What Is Plain Text?
-- Plain text is made up of printable characters in a form that can be read and understood directly by people.
-- Plain text doesn't mean that the text is unstructured: XML, SGML, and HTML are great examples of plain text that has a well-defined structure.
-- With plain text, however, you can achieve a self-describing data stream that is independent of the application that created it.
- Tip 20: Keep Knowledge in Plain Text
- Drawbacks
-- There are two major drawbacks to using plain text: (1) It may take more space to store than a compressed binary format, and (2) it may be computationally more expensive to interpret and process a plain text file.
-- Even in these situations, it may be acceptable to store metadata about the raw data in plain text.
-- Some developers may worry that by putting metadata in plain text, they're exposing it to the system's users. This fear is misplaced. Binary data may be more obscure than plain text, but it is no more secure. If you worry about users seeing passwords, encrypt them. If you don't want them changing configuration parameters, include a secure hash of all the parameter values in the file as a checksum.
- The Power of Text
-- Insurance against obsolescence
--- Human-readable forms of data, and self-describing data, will outlive all other forms of data and the applications that created them.
--- You can parse such a file with only partial knowledge of its format.
--- This is the difference between human readable and human understandable.
-- Leverage
--- Virtually every tool in the computing universe, from source code management systems to compiler environments to editors and stand-alone filters, can operate on plain text.
-- Easier testing
- Lowest Common Denominator
-- You need to ensure that all parties can communicate using a common standard. Plain text is that standard.

---

# Chapter 3: The Basic Tools
## Shell Games
- For a programmer manipulating files of text, that workbench is the command shell.
- From the shell prompt, you can invoke your full repertoire of tools, using pipes to combine them in ways never dreamt of by their original developers. From the shell, you can launch application, debuggers, browsers, editors, and utilities. You can search for files, query the status of the system, and filter output. And by programming the shell, you can build complex macro commands for activities you perform often.
-- Find all .c files modified more recently than your Makefile: find . -name '*.c' -newer Makefile -print
-- Construct a zip/tar archive of my source: zip archive.zip *.h *.c or tar cvf archive.tar *.h *.c
-- Which Java files have not been changed in the last week: find . -name "*.java" -mtime +7 -print
-- Of thos files, which use the awt libraries: find . -name '*.java' -mtime +7 -print | xargs grep 'java.awt'
- Tip 21: Use the Power of Command Shells
- Play around with your command shell, and you'll be surprised at how much more productive it makes you.

---

# Chapter 3: The Basic Tools
## Power Editing
- One Editor
-- We think it is better to know one editor very well, and use it for all editing tasks: code, documentation, memos, system administration, and so on.
-- You need to be proficient.
- Tip 22: Use a Single Editor Well
-- Make sure that the editor you choose is available on all platforms you use.
- Editor Features
-- Configurable
-- Extensible
-- Programmable
-- Syntax highlighting
-- Auto-completion
-- Auto-indentation
-- Initial code or document biolerplate
-- Tie-in to help systems
-- IDE-like features (compile, debug, and so on)
- Productivity
-- For instance, when you create an new file in a particular language, the editor can supply a template for you. It might include: 1. Name of the class or module filled in (derived from the filename); 2. Your name and/or copyright statements; 3. Skeletons for constructs in that language (constructor and destructor declarations.)
- Where to Go from Here
- What Editors Are Available?

---

# Chapter 3: The Basic Tools
## Source Code Control
- Tip 23: Always User Source Code Control
- Always. Even if you are a single-person team on a one-week project. Even if its a "throw-away" prototype. Even if the stuff you're working on isn't source code.
- Make sure that everything is under source code control - documentation, phone number lists, memos to vendors, makefiles, build and release procedures, that little shell script that burns the CD master - everything.
- Source code control and builds: You can have product builds that are automatic and repeatable.
- Don't forget that an SCCS is equally applicable to the things you do outside of work.

---

# Chapter 3: The Basic Tools
## Debugging
- Software defects manifest themselves in a variety of ways, from misunderstood requirements to coding errors.
- Psychology of Debugging
-- Embrace the fact that debugging is just problem solving, and attack it as such.
- Tip 24: Fix the Problem. Not the Blame.
-- It doesn't really matter whether the bug is your fault or someone else's. It is still your problem.
- A Debugging Mindset
-- You need to turn off many of the defenses you use each day to protect your ego, tune out any project pressures you may be under, and get yourself comfortable.
- Tip 25: Don't Panic
-- It is easy to get into a panic, especially if you are facing a deadline, or have a nervous boss or client breathing down your neck while you are trying to find the cause of the bug. But it is very important to step back a pace, and actually think about what could be causing the symptoms that you believe indicate a bug.
-- If your first reaction on witnessing a bug or seeing a bug report is "that's impossible." you are plainly wrong. Don't waste a single neuron on the train of thought that begins "but that can't happen" because quite clearly it can, and has.
-- Beware of myopia when debugging. Resist the urge to fix just the symptoms you see: it is more likely that the actual fault may be several steps removed from what you are observing, and may involve a number of other related things. Always try to discover the root cause of a problem, not just this particular appearance of it.
- Wheret to Start
-- Before you start to look at the bug, make sure that you are working on code that compiled cleanly -- without warnings.
-- You may need to interview the user who reported the bug in order to gather more data than you were initially given.
-- Artificial tests don't exercise enought of application. You must brutally test both boundary conditions and realistic end-user usage patterns. You need to do this systematically.
- Debugging Strategies
-- Once you think you know what is going on, it's time to find out what the program thinks is going on.
-- Bug Reproduction
--- The best way to start fixing a bug is to make it reproducible. After all, if you can't reproduce it, how will you know if it is ever fixed?
--- But we want more than a bug that can be reproduced by following some long series of steps: we want a bug that can be reproduced with a single command. It's a lot harder to fix a bug if you have to go through 15 steps to get to the point where the bug shows up. Sometimes by forcing yourself to isolate the circumstances that display the bug, you'll even gain an insight on how to fix it.
-- Visualize Your Data
--- Often, the easiest way to discern what a program is doing - or what it is going to do - is to get a good look at the data it is operating on.
--- Even if your debugger has limited support for visualizing data, you can still do it yourself - either by hand, with paper and pencil, or with external plotting programs.
--- The DDD debugger has some visualization capabilities, and is freely available.
-- Tracing
--- Debuggers generally focus on the state of the program now. Sometimes you need more - you need to watch the state of a program or a data structure over time. Seeing a stack trace can only tell you how you got here directly. It can't tell you what you were doing prior to this call chain, especially in event-based systems.
--- Tracing statements are those little diagnostic messages you print to the screen or to a file that say things such as "got here" and "value of x = 2." It's a primitive technique compared with IDE-style debuggers, but it is peculiarly effective at diagnosing several classes of errors that debuggers can't. Tracing is invaluable in any system where time itself is a factor: concurrent processes, real-time systems, and event-based applications.
--- Trace messages should be in a regular, consistent format: you may want to parse them automatically.
--- Corrupt variables? Check their neighborhood.
-- Rubber Ducking
--- A very simple but particularly useful technique for finding the cause of a problem is simply to explain it to someone else.
--- It sounds simple, but in explaining the problem to another person you must explicitly state things that you may take for granted when going through the code yourself. By having to verbalize some of these assumptions, you may suddenly gain new insight into the problem.
-- Process of Elimination
--- It is possible that a bug exists in the OS, the compiler, or a third-party product - but this should not be your first thought. It is much more likely that the bug exists in the application code under development. It is generally more profitable to assume that the application code is incorrectly calling into a library than to assume that the library itself is broken. Even if the problem does lie with a third party, you'll still have to eliminate your code before submitting the bug report.
- Tip 26: "select" Isn't Broken
-- We now use the phrase "select is broken" as a gentle reminder whenever one of us starts blaming the system for a fault that is likely to be our own.
-- If you "changed only one thing" and the system stopped working, that one thing was likely to be responsible, directly or indirectly, no matter how farfetched it seems.
-- If, however, you have no obvious place to start looking, you can always rely on a good old-fashioned binary search. See if the symptons are present at either of two far away spots in the code. Then look in the middle. If the problem is present, then the bug lies between the start and the middle point; otherwise, it is between the middle point and the end. You can continue in this fashion until you narrow down the spot sufficiently to identify the problem.
- The Element of Surprise
-- The amount of surprise you feel when something goes wrong is directly proportional to the amount of trust and faith you have in the code being run. That's why, when faced with a "surprising" failure, you must realize that one or more of your assumptions is wrong. Don't gloss over a routine or piece of code involved in the bug because you "know" it works. Prove it. Prove it in this context, with this data, with these boundary conditions.
- Tip 27: Don't Assume It - Prove It.
-- When you come across a surprise bug, beyong merely fixing it, you need to determine why this failure wasn't caught earlier. Consider whether you need to amend the unit or other tests so that they would have caught it.
-- Also, if the bug is the result of bad data that was propagated through a couple of levels before causing the explosion, see if better parameter checking in thos routines would have isolated it earlier.
-- Whil you're at it, are there any other places in the code that may be susceptible to this same bug? Now is the time to find and fix them. Make sure that whatever happened, you'll knnow if it happens again.
-- If it took a long time to fix this bug, ask yourself why. Is there anythong you can do to make fixing this bug easier the next time around? Perhaps you could build in better testing hooks, or write a log file analyzer.
-- Finally, if the bug is the result of someone's wrong assumption, discuss the problem with the whole team: if one person misunderstands, then it's possible many people do.
- Debugging Checklist
-- Is the problem being reported a direct result of the underlying bug, or merely a symptom?
-- Is the bug really in the compiler? Is it in the OS? Or is it in your code?
-- If you explained this problem in detail to a coworker, what would you say?
-- If the suspect code passes its unit tests, are the tests complete enough? What happens if you run the unit test with this data?
-- Do the conditions that caused this bug exist anywhere else in the system?

# The Basic Tools
## Text Manipulation
- awk, sed, Python, tcl, Perl
- These languages are important enabling technologies. Using them, you can quickly hack up utilities and prototype ideas - jobs that might take five or ten times as long using conventional languages. And that multiplying factor is crucially important to the kind of experimenting that we do.
- Tip 28: Learn a Text Manipulation Language
- Wide-ranging applicability of text manipulation languages
-- Database schema maintenance
-- Java property access
-- Test data generation
-- Book writing
-- C to Object Pascal interface
-- Generating Web documentation

---

# Chapter 3: The Basic Tools
## Code Generators
- Tip 29: Write Code That Writes Code
- Passive code generators are run once to produce a result
-- Passive code generators save typing. They are basically parameterized templates, generating a given output from a set of inputs. Once the result is produced, it becomes a full-fledged source file in the project; it will be edited, compiled, and placed under source control just like any other file. Its origins will be forgotten.
-- Uses
--- Creating new source files. A passive code generator can produce templates, source code control directives, copyright notices, and standard comment blocks for each new file in a project. We have our editors set up to do this whenever we create a new file.
--- Performing one-off conversions among programming languages.
--- Producing lookup tables and other resources that are expensive to compute at runtime.
- Active code generators are used each time their results are required
-- While passive code generators are simply a convenience, their active cousins are a necessity if you want to follow the DRY principle. With an active code generator, you can take a single representation of some piece of knowledge and convert it into all the forms your application needs. This is not duplication, because the derived froms are disposable, and are generated as needed by the code generator.
-- Whenever you find yourself trying to get two disparate environments to work together, you should consider using active code generators.
-- An alternative is to use an active code generator - take the schema and use it to generate the source code for the structures. Now, whenever the schema changes, the code used to access it also changes, automatically. Of course, this schema works only if you make the code generation part of the build process itself.
-- Another example of melding environments using code generators happens when different programming languages are used in the same application. In order to communicate, each code base will need some information in common - data structures, message formats, and field names, for example. Rather than duplicate this information, use a code generator.
- Code Generators Needn't Be Complex
-- Normally the most complex part is the parser, which analyzes the input file. Keep the input format simple, and the code generator becomes simple.
- Code Generators Needn't Generate Code

---

# Chapter 4: Pragmatic Paranoia
- Tip 30: You Can't Write Perfect Software
- Accept it as an axiom of life. Embrace it. Celebrate it. Because perfect software doesn't exist.
- Pragmatic Programmers dont't trust themselves. Knowing that no one writes perfect code, including themselves, Pragmatic Programmers code in defenses against their own mistakes.

---

# Chapter 4: Pragmatic Paranoia
## Design by Contract
- One of the best solutions for ensuring plain dealing is the contract.
- A contract defines your rights and responsibilities, as well as those of the other party.
- DBC
-- Design by Contract is a simple yet powerful technique that focuses on documenting (and agreeing to) the rights and responsibilities of softwre modules to ensure program correctness. What is a correct program? One that does no more and no less than it claims to do. Documenting and verifying that claim is the heart of Design by Contract.
-- Every function and method in a software system does something. Before it starts that something, the routine may have some expectation of the state of the world, and it may be able to make a statement about the state of the world when it concludes. Meryer describes these expectations and claims as follows:
-- Preconditions. What must be true in order for the routine to be called; the routines's requirements. A routine should never get called when its preconditions would be violated. It is the caller's responsibility to pass good data.
-- Postconditions. What the routine is guranteed to do, the state of the world when the routine is done. The fact that the routine has a postcondition implies that it will conclude: infinite lopps aren't allowd.
-- Class invariants. ?
-- The contract between a routine and any potential caller can thus be read as: If all the routine's preconditions are met by the caller, the routine shall guarantee that all postconditions and invariants will be true when it completes.
- Tip 31: Design with Contracts
- Liskov Substitution Principle: Subclasses must be usable through the base class interface without the need for the user to know the difference.
- Implementing DBC
-- The greatest benefit of using DBC may be that it forces the issue of requirements and guarantees to the forefront. Simply enumerating at design time what the input domain range is, what the boundary conditions are, and what the routine promises to deliver - or, more importantly, what it doesn't promise to deliver - is a huge leap forward in writing better software.
-- Assertions
-- Language Support
- DBC and Crashing Early
- Other Uses of Invariants
-- Loop Invariants?
-- Semantic Invariants
- Dynamic Contracts and Agents

---

# Chapter 4: Pragmatic Paranoia
## Dead Programs Tell No Lies
- Tip 32: Crash Early
- Crash, Don't Trash
- When your code discovers that something that was supposed to be impossible just happened, your program is no longer viable. Anything it does from this point forward becomes suspect, so terminate it as soon as possible. A dead program normally does a log less damage than a crippled one.

---

# Chapter 4: Pragmatic Paranoia
## Assertive Programming
- Tip 33: If It Can't Happen, Use Assertions to Ensure That It Won't
- Assertions may be turned off at compile time -- never put code that must be executed into an assert.
- Don't use assertions in place of real error handling. Assertions check for things that should never happen.
- Leave Assertions Turned On
- Turning off assertions when you deliver a program to production is like crossing a high wire without a net because you once made it across in practice. There's dramatic value, but it's hard to get life insurance.
- Even if you do have performance issues, turn off only those assertions that really hit you.

---

# Chapter 4: Pragmatic Paranoia
## When to Use Exceptions
- What Is Exceptional?
-- One of the problems with exceptions is knowing when to use them. We believe that exceptions should rarely be used as part of a program's normal flow; exceptions should be reserved for unexpected events. Assume that an uncaught exception will terminate your program and ask yourself, "Will this code still run if I remove all the exception handlers?" If the answer is "no," then maybe exceptions are being used in nonexceptional circumstances.
- Tip 34: Use Exceptions for Exceptional Problems
-- Why do we suggest this approach to exceptions? Well, an exception represents an immediate, nonlocal transfer of control - it's a kind of cascading goto. Programs that use exceptions as part of their normal processing suffer from all the readability and maintainability problems of classic spaghetti code. These programs break encapsulation: routines and their callers are more tightly coupled via exception handling.
- Error Handlers Are an Alternative
-- An error handler is a routine that is called when an error is detected. You can register a routine to handle a specific category of errors. When one of these errors occurs, the handler will be called.

---

# Chapter 4: Pragmatic Paranoia
## How to Balance Resources
- Tip 35: Finish What You Start
-- This tip is easy to apply in most circumstances. It simply means that the routine or object that allocates a resource should be responsible for deallocating it.
- Nest Allocations
-- Deallocate resources in the opposite order to that in which you allocate them. That way you won't orphan resources if one resource contains references to another.
-- When allocating the same set of resources in different places in your code, always allocate them in the same order. This will reduce the possibility of deadlock.
- It doesn't matter what kind of resources we're using - transactions, memory, files, threads, windows - the basic pattern applies: whoever allocates a resource should be responsible for deallocating it.

---

# Chapter 4: Pragmatic Paranoia
## Objects and Exceptions
- The equilibrium between allocations and deallocations is reminiscent of a class's constructor and destructor. The class represents a resource, the constructor gives you a particular object of that resource type, and the destructor removes if from your scope.
